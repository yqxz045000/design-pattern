package com.cfyj.design.pattern.facade;

/**
 * 门面设计模式： 门面设计模式也叫做外观设计模式—facade pattern ，外部与一个子系统通信与必须通过一个统一的外观对象，外观对象为子系统的一组接口提供了一致的界面。
 * 
 * 目的：
 * 将一个系统划分成若干各子系统有利于降低系统的复杂性，而这样做会使得外部系统通信时相对复杂，直接依赖较多的子系统服务，而解决这一问题的途径就是引入外观对象，为子系统中较一般的设施提供一个单一而简单的界面。
 * 
 * 参与角色： facade ：外观对象，与客户端通信的入口 1.知道哪些子系统类负责处理请求； 2.将客户端的请求代理给适当的子系统对象；
 * 3.屏蔽部分子系统不需对外暴露的功能。 system ：子系统，提供服务 1.为facade 或其他子系统提供服务
 * 
 * 协作方式： 客户端将请求发送给外观对象，外观对象将请求代理给具体的子系统提供服务，子系统收到facade 请求或其他子系统请求后，处理其负责的业务并返回。
 * 
 * 优点： 
 *   1.向客户端屏蔽了服务端的实现。1.减少客户端的调用复杂程度； 2.保障服务端的安全性，将不对外提供的服务隐藏(如果有安全性的需求)。
 *	 2.实现子系统与客户端之间的解耦。而子系统内部往往是紧耦合的，松耦合关系使得子系统内部的变化不会影响到外部客户端。
 *	 3.提供统一的入口，并不影响用户直接调用子系统类。其实服务可全部对外开放，也可以这样做。
 *缺点：
 * 	1.不符合开闭原则。在不引入新抽象外观类的情况下，增加新的子系统可能会导致修改外观类或修改客户端代码。
 * 	2.增加更多的关联关系。因为门面模式在系统前又加了一层，当系统服务修改时仍需要去修改门面层，并且每添加一个服务都需要创建新的门面或修改门面。可以引用抽象外观类来解决这一问题，对于新的业务需要，不修改原有的外观类，而是增加新的外观类，通过路由的方式来更换外观类。
 * 
 * @author chenfeng
 *
 */
public class Test {

	/**
	 * 模拟客户端请求
	 * 
	 * @param args
	 */
	public static void main(String[] args) {

		FacadeController facadeController = new FacadeController();
		String personInfo = facadeController.getPersonInfo();
		System.out.println(personInfo);
	}
}
